#!/bin/env python3

import sys
import os

for arg in sys.argv[1:]:
	arch = os.path.basename(os.path.dirname(arg))
	output = "src/generated/" + arch + ".hpp"

	instructions = {}

	print(f'Generating "{output}" from "{arg}"...')

	with open(arg) as inf:

		os.makedirs(os.path.dirname(output), exist_ok=True)
		instructions = {}

		for line in inf:
			if not 'INST ' in line:
				continue

			try:
				start = line.index('INST ') + 5 + 4
				end = line.rindex('///')

				inst = line[start:end].rstrip()[:-1]
				open_idx = inst.index('(')
				close_idx = inst.index(')')

				args = []
				mnemonic = inst[:open_idx]

				target_array = instructions.setdefault(mnemonic, [])

				for arg in inst[open_idx+1:close_idx].split(','):

					real = arg.strip()

					if len(real) == 0:
						continue

					definition = real
					value = ""

					if "=" in definition:
						parts = definition.split('=')
						definition = parts[0].strip()
						value = parts[1].strip()

					parts = definition.split(" ")
					type = parts[0].strip()
					name = parts[1].strip()

					args.append({'type': type, 'name': name, 'value': value})

				target_array.append(args)

			except Exception as e:
				print(f'Exception occurred while processing line: "{line.strip()}"')
				raise

		for mnemonic in instructions:
			arg_sets = instructions[mnemonic]

			normalized = []

			for args in arg_sets:
				partial = []

				for arg in args:
					if arg['value'] != "":
						normalized.append(partial.copy())

					partial.append(arg['type'])

				normalized.append(partial)

			instructions[mnemonic] = sorted(normalized, key=lambda x: len(x))

	with open(output, 'w') as ouf:

		ouf.write("#pragma once\n\n")

		pad = " " * (8 - len(arch))

		ouf.write(f"// ---------------------------------------------------------------- //\n")
		ouf.write(f"// Warning! Do not modify this file, nor add it to version control! //\n")
		ouf.write(f"// ---------------------------------------------------------------- //\n")
		ouf.write(f"// This file was auto generated using 'util/ingen.py', and is auto  //\n")
		ouf.write(f"// re-generated by CMake when 'src/asm/{arch}/writer.hpp' changes.{pad}//\n")
		ouf.write(f"// ---------------------------------------------------------------- //\n\n")

		ouf.write(f'static bool try_parse_instruction(TokenStream& statement, BufferWriter& writer) {{\n\n')

		for mnemonic in instructions:

			argc = 0
			aidx = 0

			ouf.write(f'\tif (statement.accept("{mnemonic}")) {{\n')
			sets = instructions[mnemonic]

			for sdx in range(len(sets)):
				set = sets[sdx]
				count = len(set)
				argc = count
				#i = 0

				try_prefix = ""
				try_suffix = ""
				try_indent = ""

				ndx = sdx + 1
				if ndx < len(sets):
					if count >= len(sets[ndx]):
						try_prefix = "\t\t\ttry {\n"
						try_suffix = "\t\t\t} catch (const std::runtime_error& e) {}\n"
						try_indent = "\t"

				new_args = count
				args = []

				if sdx > 0:
					new_args -= len(sets[sdx - 1])

				for new_arg in range(0, new_args):
					ouf.write(f'\t\tTokenStream a{aidx} = statement.expression();\n')
					aidx += 1

				for i in range(0, count):
					args.append(f'parse_argument<{set[i]}>(a{i})')

				ouf.write(f'\n\t\tif (statement.empty()) {{\n')
				ouf.write(try_prefix)
				ouf.write(f'\t\t\t{try_indent}writer.put_{mnemonic}({", ".join(args)});\n')
				ouf.write(f'\t\t\t{try_indent}return true;\n')
				ouf.write(try_suffix)
				ouf.write(f'\t\t}}\n\n')

			ouf.write(f'\t\tthrow std::runtime_error {{"Invalid argument count"}};\n')
			ouf.write(f'\t}}\n\n')

		ouf.write(f'\treturn false;\n')
		ouf.write(f'}}\n')
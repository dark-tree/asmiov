#!/bin/env python3
# Usage: ingen.py <input>

from datetime import datetime
import sys
import os

for arg in sys.argv[1:]:
	arch = os.path.basename(os.path.dirname(arg))
	output = "src/generated/" + arch + ".hpp"

	instructions = {}

	print(f' -- Processing "{arg}"...')

	with open(arg) as inf:

		os.makedirs(os.path.dirname(output), exist_ok=True)
		instructions = {}

		for line in inf:
			if not 'INST ' in line:
				continue

			try:
				start = line.index('INST ') + 5 + 4
				end = line.rindex('///')

				inst = line[start:end].rstrip()[:-1]
				open_idx = inst.index('(')
				close_idx = inst.index(')')

				args = []
				mnemonic = inst[:open_idx]

				target_array = instructions.setdefault(mnemonic, [])

				for arg in inst[open_idx+1:close_idx].split(','):

					real = arg.strip()

					if len(real) == 0:
						continue

					definition = real
					value = ""

					if "=" in definition:
						parts = definition.split('=')
						definition = parts[0].strip()
						value = parts[1].strip()

					parts = definition.split(" ")
					type = parts[0].strip()
					name = parts[1].strip()

					args.append({'type': type, 'name': name, 'value': value})

				target_array.append(args)

			except Exception as e:
				print(f'Exception occured while prcessing line: "{line.strip()}"')
				raise

		for mnemonic in instructions:
			arg_sets = instructions[mnemonic]

			normalized = []

			for args in arg_sets:
				partial = []

				for arg in args:
					if arg['value'] != "":
						normalized.append(partial.copy())

					partial.append(arg['type'])

				normalized.append(partial)

			instructions[mnemonic] = sorted(normalized, key=lambda x: len(x))

	print(f' -- Generating "{output}"...')

	with open(output, 'w') as ouf:

		ouf.write("#pragma once\n\n")

		pad = " " * (8 - len(arch))

		ouf.write(f"// ---------------------------------------------------------------- //\n")
		ouf.write(f"// Warning! Do not modify this file, nor add it to version control! //\n")
		ouf.write(f"// ---------------------------------------------------------------- //\n")
		ouf.write(f"// This file as auto generated using 'util/ingen.py', and is auto   //\n")
		ouf.write(f"// re-generated by CMake when 'src/asm/{arch}/writer.hpp' changes.{pad}//\n")
		ouf.write(f"// ---------------------------------------------------------------- //\n\n")

		ouf.write(f'static bool tryParseInstruction(TokenStream& stream, BufferWriter& writer) {{\n\n')

		for mnemonic in instructions:

			argc = 0
			aidx = 0
			args = []

			ouf.write(f'\tif (stream.accept("{mnemonic}")) {{\n')

			ouf.write(f'\t\tTokenStream statement = stream.tail();\n')

			for set in instructions[mnemonic]:
				count = len(set)
				new = count - argc
				argc = count
				i = 0

				while aidx < count:
					arg_name = f'a{aidx}';
					ouf.write(f'\t\tTokenStream {arg_name} = statement.expression();\n')
					aidx += 1
					args.append(f'parseArgument<{set[i]}>({arg_name})')
					i += 1

				ouf.write(f'\n\t\tif (statement.empty()) {{\n')
				ouf.write(f'\t\t\twriter.put_{mnemonic}({", ".join(args)});\n')
				ouf.write(f'\t\t\treturn true;\n')
				ouf.write(f'\t\t}}\n\n')

			ouf.write(f'\t\tthrow std::runtime_error {{"Invalid argument count!"}};\n')
			ouf.write(f'\t}}\n\n')

		ouf.write(f'\treturn false;\n')
		ouf.write(f'}}\n')